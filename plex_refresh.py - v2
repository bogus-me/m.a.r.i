#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio, datetime as dt, json, os, sqlite3, sys, time, socket, unicodedata
from typing import Any, Dict, List, Optional, Tuple

import requests, psutil
from dotenv import load_dotenv
from plexapi.server import PlexServer  # type: ignore

# --- Telegram (Aiogram) ---
ENABLE_TELEGRAM_IMPORT = False
try:
    from aiogram import Bot as TgBot # type: ignore
    from aiogram.client.session.aiohttp import AiohttpSession # type: ignore
    ENABLE_TELEGRAM_IMPORT = True
except Exception:
    pass

# --- Discord ---
ENABLE_DISCORD_IMPORT = False
try:
    import discord # type: ignore
    from discord.ext import commands # type: ignore
    ENABLE_DISCORD_IMPORT = True
except Exception:
    pass

import warnings, urllib3
warnings.simplefilter("ignore", urllib3.exceptions.InsecureRequestWarning)
urllib3.disable_warnings()

try:
    sys.stdout.reconfigure(line_buffering=True)
except:
    pass

load_dotenv()

# =====================================================================
# EXCLUDE-LIBRARIES ‚Äì werden vollst√§ndig vom Fixing ausgeschlossen
# =====================================================================

EXCLUDE_LIBRARIES = {
    "Filme - Konzerte",
    "Filme - Sport",
    "Filme - Adult",
    "Filme - O-Ton",
    "TV - Comedy",
    "TV - Reality_Soap",
}

# =====================================================================
# ENV
# =====================================================================

def env_required(name: str) -> str:
    v = os.getenv(name, "").strip()
    if not v:
        print(f"[ERROR] ENV fehlt: {name}"); sys.exit(1)
    return v

def env_int(name: str) -> int:
    val = env_required(name)
    try: return int(val)
    except: print(f"[ERROR] {name} muss int sein"); sys.exit(1)

def env_bool(name: str) -> bool:
    v = env_required(name).lower()
    if v not in ("true","false"):
        print(f"[ERROR] {name} muss true/false sein"); sys.exit(1)
    return v == "true"

# =====================================================================
# KONFIG
# =====================================================================

PLEX_URL       = env_required("PLEX_URL")
PLEX_TOKEN     = env_required("PLEX_TOKEN")
TMDB_API_KEY   = env_required("TMDB_API_KEY")
PLEX_TIMEOUT   = int(os.getenv("PLEX_TIMEOUT", "30"))

REFRESH_INTERVAL_DAYS = env_int("REFRESH_INTERVAL_DAYS")
REFRESH_TIME          = env_required("REFRESH_TIME")

RAW_LOG_FILE = env_required("LOG_FILE")
LOG_MAX_LINES = env_int("LOG_MAX_LINES")
HEALTH_FILE = env_required("HEALTH_FILE")
MSG_STATE_FILE = env_required("MSG_STATE_FILE")
HEALTHCHECK_MAX_DAYS = env_int("HEALTHCHECK_MAX_DAYS")
HEALTHCHECK_INTERVAL_MINUTES = env_int("HEALTHCHECK_INTERVAL_MINUTES")

MAX_ITEMS_PER_RUN = 200
SCAN_TIME_LIMIT_SECONDS = 600
SMART_LOOKBACK_DAYS = 30
PLEX_SCAN_CHECK_INTERVAL = 10
MAX_FAILS = 5
COOLDOWN_STEPS_DAYS = [1, 7, 14, 30]

LOG_BASE = os.path.dirname(RAW_LOG_FILE) or "/app"
LOG_DIR = os.path.join(LOG_BASE, "logs")
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, os.path.basename(RAW_LOG_FILE))

def db_path():
    return os.path.join(LOG_DIR, "refresh_state.db")

DB_PATH = os.getenv("REFRESH_DB_PATH", db_path())

# =====================================================================
# Discord / Telegram ENV
# =====================================================================

ENABLE_DISCORD = env_bool("ENABLE_DISCORD_NOTIFY")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN","")
DISCORD_CH_ID_RAW = os.getenv("DISCORD_CHANNEL_ID","0")

ENABLE_TELEGRAM = env_bool("ENABLE_TELEGRAM_NOTIFY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN","")
TELEGRAM_CHAT_ID_RAW = os.getenv("TELEGRAM_CHAT_ID","0")

if ENABLE_DISCORD:
    try: DISCORD_CHANNEL_ID = int(DISCORD_CH_ID_RAW)
    except: print("[ERROR] DISCORD_CHANNEL_ID ung√ºltig"); sys.exit(1)
else:
    DISCORD_CHANNEL_ID = 0

if ENABLE_TELEGRAM:
    try: TELEGRAM_CHAT_ID = int(TELEGRAM_CHAT_ID_RAW)
    except: print("[ERROR] TELEGRAM_CHAT_ID ung√ºltig"); sys.exit(1)
else:
    TELEGRAM_CHAT_ID = 0

bot = None
tg_bot = None

# =====================================================================
# HIGH PERFORMANCE LOGGING
# =====================================================================

_log_lock = asyncio.Lock()

def _fast_read_head(path: str, max_lines: int) -> List[str]:
    lines = []
    try:
        with open(path, "r") as f:
            for i, ln in enumerate(f):
                if i >= max_lines:
                    break
                lines.append(ln.rstrip("\n"))
    except:
        pass
    return lines

# üö® FIX: sync-wrapper f√ºr alle sync-Aufrufe
def log_sync(msg: str, p="MAIN"):
    asyncio.create_task(log(msg, p))

async def log(msg: str, p="MAIN"):
    ts = dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    line = f"[{ts}] [{p}] {msg}"
    print(line, flush=True)

    async with _log_lock:
        try:
            old_lines = _fast_read_head(LOG_FILE, LOG_MAX_LINES - 1)
            tmp_path = LOG_FILE + ".tmp"
            with open(tmp_path, "w") as f:
                f.write(line + "\n")
                for ln in old_lines:
                    f.write(ln + "\n")
            os.replace(tmp_path, LOG_FILE)
        except:
            pass

async def log_extra(name: str, msg: str):
    ts = dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    path = name if os.path.isabs(name) else os.path.join(LOG_DIR, name)

    async with _log_lock:
        try:
            with open(path, "a") as f:
                f.write(f"[{ts}] {msg}\n")
        except:
            pass

# =====================================================================
# HEALTH, STATUS, CPU
# =====================================================================

def write_health(ok=True):
    try:
        with open(HEALTH_FILE,"w") as f:
            f.write(("OK" if ok else "FAIL")+"|"+dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S"))
        log_sync("Health aktualisiert","HEALTH")
    except Exception as e:
        log_sync(f"Health-Fehler: {e}","HEALTH")

status = {
    "plex_name":"‚Äî",
    "mode":"INIT",
    "status_line":"‚è≥ Initialisiere‚Ä¶",
    "next_run":"‚Äî",
    "health":"Noch kein Health.",
    "last_refresh":"Noch kein Refresh.",
    "last_refresh_details":"",
    "cpu_line":"‚Äî",
    "last_error":"",
    "stats_block":"",
}

def load_state():
    if os.path.exists(MSG_STATE_FILE):
        try: return json.load(open(MSG_STATE_FILE))
        except: pass
    return {}

def save_state(d: Dict[str,Any]):
    try:
        json.dump(d, open(MSG_STATE_FILE,"w"), indent=2)
    except:
        pass

msg_state = load_state()
state_lock = asyncio.Lock()
if isinstance(msg_state.get("last_status"), dict):
    status.update(msg_state["last_status"])

PROC = psutil.Process()
cpu_vals = []
cpu_peak = 0.0

async def cpu_sampler():
    global cpu_peak
    while True:
        try:
            v = PROC.cpu_percent(interval=None)
            cpu_vals.append(v)
            cpu_peak = max(cpu_peak, v)
        except:
            pass
        await asyncio.sleep(1)

# =====================================================================
# UTIL
# =====================================================================

def format_dur(sec: float) -> str:
    sec = int(sec)
    m, s = divmod(sec, 60)
    h, m = divmod(m, 60)
    d, h = divmod(h, 24)
    out=[]
    if d: out.append(f"{d}d")
    if h: out.append(f"{h}h")
    if m: out.append(f"{m}min")
    if not out: out.append(f"{s}s")
    return " ".join(out)

def human_until(target: dt.datetime) -> str:
    now = dt.datetime.now()
    diff = max(0, int((target-now).total_seconds()))
    m = diff//60; h=m//60; m%=60
    return f"in {h}h {m}min" if h else f"in {m}min"

def next_target_datetime() -> dt.datetime:
    now = dt.datetime.now()
    h,m = map(int, REFRESH_TIME.split(":"))
    base = now.replace(hour=h, minute=m, second=0, microsecond=0)
    while base <= now:
        base += dt.timedelta(days=REFRESH_INTERVAL_DAYS)
    return base

def next_run_human(t: dt.datetime) -> str:
    return f"{human_until(t)}\n{t:%d.%m.%Y %H:%M}"

def iso_now() -> str:
    return dt.datetime.now().isoformat(timespec="seconds")

def iso_in_days(d: int) -> str:
    return (dt.datetime.now()+dt.timedelta(days=d)).isoformat(timespec="seconds")

# =====================================================================
# DB
# =====================================================================

SCHEMA_SQL = """
PRAGMA journal_mode=WAL;
CREATE TABLE IF NOT EXISTS media_state(
    rating_key TEXT PRIMARY KEY,
    library TEXT,
    first_seen TEXT,
    last_scanned TEXT,
    last_updated_at TEXT,
    fail_count INTEGER DEFAULT 0,
    ignore_until TEXT,
    state TEXT DEFAULT 'active',
    note TEXT
);
CREATE INDEX IF NOT EXISTS idx_media_lib ON media_state(library);
"""

def db_connect():
    c=sqlite3.connect(DB_PATH, isolation_level=None, check_same_thread=False)
    c.row_factory=sqlite3.Row
    return c

def db_init():
    c=db_connect()
    with c: c.executescript(SCHEMA_SQL)
    c.close()

def db_get_media(key: str):
    c=db_connect()
    try:
        cur=c.execute("SELECT * FROM media_state WHERE rating_key=?", (key,))
        return cur.fetchone()
    finally:
        c.close()

def db_upsert_media(key, lib, updated, fails, state, until, note):
    c=db_connect()
    try:
        row=db_get_media(key)
        first=row["first_seen"] if row and row["first_seen"] else iso_now()
        c.execute("""
            INSERT INTO media_state(rating_key,library,first_seen,last_scanned,last_updated_at,
            fail_count,ignore_until,state,note)
            VALUES(?,?,?,?,?,?,?,?,?)
            ON CONFLICT(rating_key) DO UPDATE SET
                library=excluded.library,
                last_scanned=excluded.last_scanned,
                last_updated_at=excluded.last_updated_at,
                fail_count=excluded.fail_count,
                ignore_until=excluded.ignore_until,
                state=excluded.state,
                note=excluded.note
        """,(key,lib,first,iso_now(),updated,fails,until,state,note))
    finally:
        c.close()

def db_count_dead_total()->int:
    c=db_connect()
    try:
        cur=c.execute("SELECT COUNT(*) c FROM media_state WHERE state='dead'")
        return cur.fetchone()["c"]
    finally:
        c.close()

# =====================================================================
# TITLE NORMALIZATION
# =====================================================================

BIDI_CHARS = {
    "\u200e","\u200f","\u202a","\u202b","\u202c","\u202d","\u202e",
    "\ufeff","\u2066","\u2067","\u2068","\u2069"
}
BIDI_MARKERS = [
    "[U+200E]","[U+200F]","[U+202A]","[U+202B]","[U+202C]","[U+202D]","[U+202E]"
]

def clean_bidi(s:str)->str:
    if not isinstance(s,str): return s
    for ch in BIDI_CHARS: s=s.replace(ch,"")
    for m in BIDI_MARKERS: s=s.replace(m,"")
    return s.strip()

def normalize_title(s:str)->str:
    if not s: return ""
    s=clean_bidi(s)
    s=unicodedata.normalize("NFKD",s)
    s="".join(c for c in s if not unicodedata.combining(c))
    s=s.lower()

    for y in range(1900,2101):
        s=s.replace(str(y)," ")

    repl={"(":" ",")":" ","[":" ","]":" ","{":" ","}":" ","_":" ","-":" ",".":" ",":":" ",",":" "}
    for a,b in repl.items(): s=s.replace(a,b)

    while "  " in s: s=s.replace("  "," ")
    return s.strip()

def ratio(a:str,b:str)->float:
    if not a or not b: return 0.0
    a,b=a.lower(),b.lower()
    total=max(len(a),len(b))
    match=sum(1 for i in range(min(len(a),len(b))) if a[i]==b[i])
    return match/total

def smart_fuzzy(a:str,b:str)->float:
    if not a or not b: return 0.0
    na,nb=normalize_title(a),normalize_title(b)
    if not na or not nb: return 0.0
    base=ratio(na,nb)
    if na in nb or nb in na: base=max(base,0.90)
    return base

# =====================================================================
# TMDB
# =====================================================================

TMDB_STATUS="unknown"
TMDB_LAST_ERROR=""
TMDB_LAST_CHECK=None
TMDB_LAST_LOOKUP=None
TMDB_TRIES=0
TMDB_HITS=0

TMDB_MOVIE_SEARCH="https://api.themoviedb.org/3/search/movie"
TMDB_TV_SEARCH="https://api.themoviedb.org/3/search/tv"
TMDB_FIND_EXTERNAL="https://api.themoviedb.org/3/find/{ext_id}"

def tmdb_request(url,params):
    params["api_key"]=TMDB_API_KEY
    try:
        r=requests.get(url,params=params,timeout=10,verify=False)
        if r.status_code!=200:
            log_sync(f"TMDB HTTP {r.status_code}: {url}","TMDB")
            return None
        return r.json()
    except Exception as e:
        log_sync(f"TMDB Fehler: {e}","TMDB")
        return None

def tmdb_check_connection():
    global TMDB_STATUS,TMDB_LAST_ERROR,TMDB_LAST_CHECK
    TMDB_LAST_CHECK=iso_now()
    try:
        r=requests.get("https://api.themoviedb.org/3/configuration",
                       params={"api_key":TMDB_API_KEY},timeout=8,verify=False)
        if r.status_code==200:
            TMDB_STATUS="ok"; TMDB_LAST_ERROR=""
            log_sync("TMDB OK","TMDB")
            return True
        TMDB_STATUS="error"; TMDB_LAST_ERROR=f"HTTP {r.status_code}"
        return False
    except Exception as e:
        TMDB_STATUS="error"; TMDB_LAST_ERROR=str(e)
        return False

def extract_year(itm)->Optional[int]:
    try:
        y=getattr(itm,"year",None)
        return y if isinstance(y,int) else None
    except: return None

def tmdb_search_movie(title,year):
    p={"query":title}
    if year: p["year"]=year
    return tmdb_request(TMDB_MOVIE_SEARCH,p)

def tmdb_search_tv(title,year):
    p={"query":title}
    if year: p["first_air_date_year"]=year
    return tmdb_request(TMDB_TV_SEARCH,p)

def tmdb_find_by_external(ext_id,src):
    if src=="tvdb": e="tvdb_id"
    elif src=="imdb": e="imdb_id"
    else: return None
    url=TMDB_FIND_EXTERNAL.format(ext_id=ext_id)
    return tmdb_request(url,{"external_source":e})

def try_external_lookup(itm):
    for g in getattr(itm,"guids",[]):
        gid=(getattr(g,"id","") or "").lower()
        ext = (g.id or "").split("/")[-1]
        if "tvdb" in gid:
            j=tmdb_find_by_external(ext,"tvdb")
            if j and j.get("tv_results"):
                return j["tv_results"][0]["id"]
        if "imdb" in gid:
            j=tmdb_find_by_external(ext,"imdb")
            if j:
                if j.get("movie_results"):
                    return j["movie_results"][0]["id"]
                if j.get("tv_results"):
                    return j["tv_results"][0]["id"]
    return None

def try_search_movie(itm):
    global TMDB_TRIES,TMDB_LAST_LOOKUP,TMDB_HITS
    title=getattr(itm,"title","")
    year=extract_year(itm)

    TMDB_TRIES+=1; TMDB_LAST_LOOKUP=iso_now()
    log_sync(f"TMDB Suche Film: {title} ({year})","TMDB")

    j=tmdb_search_movie(title,year)
    if not j: return None

    best_id=None; best_score=0.0
    for r in j.get("results",[]):
        score=smart_fuzzy(title,r.get("title","") or "")
        if year:
            try:
                r_year=int((r.get("release_date","") or "0")[:4])
                if abs(r_year-year)>1: continue
            except: pass
        if score>=0.85 and score>best_score:
            best_score=score; best_id=r["id"]

    if best_id:
        TMDB_HITS+=1
        awaitable = log_extra("tmdb_hits.log",
            f"HIT | movie | {clean_bidi(title)} | id={best_id} | s={best_score:.2f}")
        asyncio.create_task(awaitable)
        return best_id

    asyncio.create_task(
        log_extra("tmdb_hits.log", f"MISS | movie | {clean_bidi(title)} | year={year}")
    )
    return None

def try_search_show(itm):
    global TMDB_TRIES,TMDB_LAST_LOOKUP,TMDB_HITS
    title=getattr(itm,"title","")
    year=extract_year(itm)

    TMDB_TRIES+=1; TMDB_LAST_LOOKUP=iso_now()
    log_sync(f"TMDB Suche Serie: {title} ({year})","TMDB")

    j=tmdb_search_tv(title,year)
    if not j: return None

    best_id=None; best_score=0.0
    for r in j.get("results",[]):
        score=smart_fuzzy(title,r.get("name","") or "")
        if year:
            try:
                r_year=int((r.get("first_air_date","") or "0")[:4])
                if abs(r_year-year)>1: continue
            except: pass
        if score>=0.85 and score>best_score:
            best_score=score; best_id=r["id"]

    if best_id:
        TMDB_HITS+=1
        asyncio.create_task(
            log_extra("tmdb_hits.log",
                f"HIT | tv | {clean_bidi(title)} | id={best_id} | s={best_score:.2f}")
        )
        return best_id

    asyncio.create_task(
        log_extra("tmdb_hits.log", f"MISS | tv | {clean_bidi(title)} | year={year}")
    )
    return None

def tmdb_find_guid_for_item(itm):
    ext=try_external_lookup(itm)
    if ext: return ext
    t=getattr(itm,"type","")
    if t=="movie": return try_search_movie(itm)
    if t=="show": return try_search_show(itm)
    return None

# =====================================================================
# GUID-SETTER
# =====================================================================

def set_guid(itm, tmdb_id: int)->bool:
    tag=f"tmdb://{tmdb_id}"
    title=clean_bidi(getattr(itm,"title","???"))

    fn = getattr(itm,"editGuid",None) or getattr(itm,"addGuid",None)
    if not fn:
        log_sync(f"GUID nicht gesetzt (kein edit/add): {title}","GUID")
        return False

    try:
        fn([tag])
    except Exception as e:
        log_sync(f"GUID-Fehler: {title}: {e}","GUID")
        return False

    try:
        fresh=itm._server.fetchItem(itm.ratingKey)
        guids=[getattr(g,"id","") for g in getattr(fresh,"guids",[])]
        if tag in guids:
            log_sync(f"GUID gesetzt: {title} -> {tag}","GUID")
            return True
        log_sync(f"GUID verworfen von Plex: {title}","GUID")
        return False
    except Exception as e:
        log_sync(f"GUID-Verify-Fehler: {title}: {e}","GUID")
        return False

# =====================================================================
# REFRESH-NEEDS
# =====================================================================

def needs_refresh(itm)->Tuple[bool,Dict[str,Any]]:
    title=getattr(itm,"title","???")
    thumb=getattr(itm,"thumb",None)
    summary=(getattr(itm,"summary","") or "").strip()
    rating=getattr(itm,"rating",None)
    guids=getattr(itm,"guids",[])

    missing_guid=not bool(guids)
    missing_thumb=(thumb is None)
    missing_summary=not summary
    missing_rating=(rating is None)

    need = (
        missing_guid
        or (missing_thumb and missing_summary)
        or (missing_rating and (missing_guid or missing_thumb or missing_summary))
    )

    return need, {
        "title":clean_bidi(title),
        "missing_guid":missing_guid,
        "missing_thumb":missing_thumb,
        "missing_summary":missing_summary,
        "missing_rating":missing_rating
    }

# =====================================================================
# BEFORE DISCORD
# =====================================================================

def fmt_tmdb_dt(val: Optional[str]) -> str:
    if not val:
        return "‚Äî"
    try:
        d = dt.datetime.fromisoformat(val)
        return d.strftime("%d.%m.%Y %H:%M")
    except:
        return val

# =====================================================================
# DISCORD ‚Äì kompakt & stabil
# =====================================================================

DISCORD_UPDATE_INTERVAL = 3.0
_last_discord_update = 0.0
_pending_discord = False
_last_payload = ""
discord_send_lock = asyncio.Lock()

def _build_payload()->str:
    s=status
    nr=str(s["next_run"]).splitlines()
    line=nr[0] if nr else "‚Äî"
    date=nr[1] if len(nr)>=2 else "‚Äî"
    return "|".join([
        s["status_line"], s["mode"], line, date,
        s["last_refresh"], s["health"], s["last_refresh_details"],
        s.get("stats_block",""), s["last_error"], s["cpu_line"]
    ])

async def update_discord_embed():
    global _pending_discord
    _pending_discord=True
    await _discord_maybe_send()

async def _discord_maybe_send():
    global _pending_discord,_last_discord_update,_last_payload
    async with discord_send_lock:
        if not _pending_discord: return
        now=time.time()
        if now-_last_discord_update < DISCORD_UPDATE_INTERVAL: return
        _pending_discord=False
        _last_discord_update=now

        payload=_build_payload()
        if payload!=_last_payload:
            _last_payload=payload
            await _discord_send_core()

async def _discord_send_core():
    try:
        await _discord_embed_raw()
    except Exception as e:
        if ENABLE_DISCORD_IMPORT and isinstance(e,discord.HTTPException) and getattr(e,"status",None)==429:
            d=float(getattr(e,"retry_after",3))
            log_sync(f"[DISCORD] 429 ‚Äì warte {d:.1f}s","DISCORD")
            await asyncio.sleep(d)
            await _discord_embed_raw()
        else:
            log_sync(f"Discord Fehler: {e}","DISCORD")

async def _discord_embed_raw():
    if not (ENABLE_DISCORD and ENABLE_DISCORD_IMPORT and DISCORD_CHANNEL_ID):
        return
    global bot
    if bot is None: return

    s=status
    now=dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    nr=str(s["next_run"]).splitlines()
    next_line=nr[0] if nr else "‚Äî"
    next_date=nr[1] if len(nr)>=2 else "‚Äî"

    tmdb_state="üü¢ OK" if TMDB_STATUS=="ok" else f"üî¥ Fehler ‚Äì {TMDB_LAST_ERROR or 'unbekannt'}"
    tmdb_rate=f"{(TMDB_HITS/max(1,TMDB_TRIES)*100):.0f}%" if TMDB_TRIES else "‚Äî"

    desc = (
        f"**SYSTEMSTATUS**\n"
        f"‚Ä¢ {s['status_line']}\n"
        f"‚Ä¢ Modus: {s['mode']}\n\n"
        f"**PLANUNG**\n"
        f"‚Ä¢ N√§chster Lauf: {next_line}\n"
        f"‚Ä¢ Datum: {next_date}\n\n"
        f"**LETZTER LAUF**\n"
        f"‚Ä¢ {s['last_refresh']}\n\n"
        f"**HEALTH**\n"
        f"‚Ä¢ {s['health']}\n\n"
        f"**TMDB**\n"
        f"‚Ä¢ Status: {tmdb_state}\n"
        f"‚Ä¢ Trefferquote: {tmdb_rate}\n"
        f"‚Ä¢ Letzter Lookup: {fmt_tmdb_dt(TMDB_LAST_LOOKUP)}\n"
        f"‚Ä¢ Letzter Check: {fmt_tmdb_dt(TMDB_LAST_CHECK)}\n\n"
        f"**STATS**\n"
        f"{s.get('stats_block','Noch keine Stats.')}\n"
    )

    if len(desc)>4000:
        desc = desc[:4000] + "\n‚Ä¶ (gek√ºrzt)"

    color = (
        0xFF0000 if s["mode"]=="ERROR"
        else 0xFFA500 if s["mode"]!="IDLE"
        else 0x00FF00
    )

    emb=discord.Embed(description=desc,color=color)
    emb.set_footer(text=f"Aktualisiert: {now}")

    ch = bot.get_channel(DISCORD_CHANNEL_ID) or await bot.fetch_channel(DISCORD_CHANNEL_ID)

    async with state_lock:
        mid = msg_state.get("discord_main")
        try:
            if mid:
                msg=await ch.fetch_message(mid)
                await msg.edit(embed=emb)
                return
        except:
            pass

        msg=await ch.send(embed=emb)
        msg_state["discord_main"]=msg.id
        save_state(msg_state)

# =====================================================================
# TELEGRAM ‚Äì Aiogram stabil
# =====================================================================

async def update_telegram_message():
    if not (ENABLE_TELEGRAM and ENABLE_TELEGRAM_IMPORT and TELEGRAM_CHAT_ID):
        return
    global tg_bot
    if tg_bot is None: return

    s=status
    now=dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    last_ref=s["last_refresh"]
    prefix="" if last_ref.startswith(("üîÑ","‚ùå","‚úÖ")) else "‚Ä¢ "

    tmdb_state="üü¢ OK" if TMDB_STATUS=="ok" else f"üî¥ Fehler ‚Äì {TMDB_LAST_ERROR or 'unbekannt'}"
    tmdb_rate=f"{(TMDB_HITS/max(1,TMDB_TRIES)*100):.0f}%" if TMDB_TRIES else "‚Äî"

    txt=(
        f"üü¢ <b>Status:</b> {s['status_line']}\n"
        f"‚öôÔ∏è <b>Modus:</b> {s['mode']}\n\n"
        f"üïí <b>N√§chster Lauf:</b> {s['next_run']}\n\n"
        f"üìÖ <b>Letzter Lauf:</b>\n{prefix}{last_ref}\n\n"
        f"üé¨ <b>TMDB</b>\n"
        f"‚Ä¢ Status: {tmdb_state}\n"
        f"‚Ä¢ Trefferquote: {tmdb_rate}\n"
        f"‚Ä¢ Lookup: {fmt_tmdb_dt(TMDB_LAST_LOOKUP)}\n"
        f"‚Ä¢ Check: {fmt_tmdb_dt(TMDB_LAST_CHECK)}"
    )

    if s["cpu_line"]!="‚Äî": txt+=f"\n‚Ä¢ <b>CPU:</b> {s['cpu_line']}"
    if s["last_refresh_details"]: txt+=f"\n\n{s['last_refresh_details']}"
    if s["stats_block"]: txt+=f"\n\n{s['stats_block']}"
    if s["last_error"]: txt+=f"\n\n‚ùå <b>Fehler:</b> {s['last_error']}"
    txt+=f"\n\n‚è±Ô∏è <i>Aktualisiert:</i> {now}"

    async with state_lock:
        mid=msg_state.get("telegram_main")
        try:
            if mid:
                await tg_bot.edit_message_text(
                    chat_id=TELEGRAM_CHAT_ID,
                    message_id=mid,
                    text=txt,
                    parse_mode="HTML"
                )
                return
        except:
            pass

        sent=await tg_bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=txt,
            parse_mode="HTML"
        )
        msg_state["telegram_main"]=sent.message_id
        save_state(msg_state)

async def update_embed():
    await update_discord_embed()
    await update_telegram_message()

# =====================================================================
# PLEX-WAIT / SCAN
# =====================================================================

def is_plex_reachable(url)->bool:
    try:
        host=url.split("//",1)[-1].split("/")[0].split(":")[0]
        socket.gethostbyname(host)
        r=requests.get(url+"/identity",timeout=3,verify=False)
        return r.status_code==200
    except:
        return False

async def wait_until_plex_online(url):
    tries=0
    while True:
        if is_plex_reachable(url): return
        tries+=1
        if tries==3:
            log_sync("Plex offline ‚Äì Warte 2min","REFRESH")
            status["mode"]="PAUSE"
            status["status_line"]="‚è∏Ô∏è Plex offline ‚Äì Boot-Fenster."
            await update_embed()
            await asyncio.sleep(120)
            tries=0
        else:
            log_sync("Plex offline ‚Äì retry in 5s","REFRESH")
            status["mode"]="PAUSE"
            status["status_line"]="‚è∏Ô∏è Plex offline ‚Äì retry‚Ä¶"
            await update_embed()
            await asyncio.sleep(5)

def plex_is_scanning_sync(plex)->bool:
    try:
        for s in plex.library.sections():
            if getattr(s,"isScanning",False): return True
    except:
        pass
    return False

async def plex_is_scanning_async(plex)->bool:
    loop=asyncio.get_running_loop()
    return await loop.run_in_executor(None, plex_is_scanning_sync, plex)

async def wait_until_plex_ready(plex):
    while True:
        try:
            if not await plex_is_scanning_async(plex): return
            log_sync("Plex-Scan erkannt ‚Äì Pause","REFRESH")
            status["mode"]="PAUSE"
            status["status_line"]="‚è∏Ô∏è Plex scannt‚Ä¶"
            await update_embed()
        except Exception as e:
            log_sync(f"Scan-Check Fehler: {e}","REFRESH")
            return
        await asyncio.sleep(PLEX_SCAN_CHECK_INTERVAL)

async def plex_connect_async() -> PlexServer:
    log_sync("[INIT] Verbinde mit Plex‚Ä¶", "REFRESH")
    await wait_until_plex_online(PLEX_URL)

    plex = PlexServer(PLEX_URL, PLEX_TOKEN, timeout=PLEX_TIMEOUT)
    plex._session.verify = False

    try:
        secs = plex.library.sections()
        rel = [s for s in secs if s.type in ("movie", "show")]
        log_sync(f"[INIT] Bibliotheken geladen: {len(rel)} relevante Sektionen", "REFRESH")
    except Exception as e:
        log_sync(f"[INIT-ERROR] Fehler beim Laden der Bibliotheken: {e}", "REFRESH")

    return plex

async def safe_fetch(plex, key, retries=3):
    loop=asyncio.get_running_loop()
    def _f():
        try: return plex.fetchItem(key)
        except: return None
    for _ in range(retries):
        itm=await loop.run_in_executor(None,_f)
        if itm is not None: return itm
        await asyncio.sleep(0.2)
    return None

# =====================================================================
# REFRESH CORE
# =====================================================================

async def refresh_item_and_check(plex, itm)->bool:
    loop=asyncio.get_running_loop()
    def _refresh():
        try: itm.refresh()
        except: pass

    await loop.run_in_executor(None,_refresh)

    def _fetch():
        try: return plex.fetchItem(itm.ratingKey)
        except: return None

    fresh=await loop.run_in_executor(None,_fetch)
    if fresh is None: return False

    still, _ = needs_refresh(fresh)
    return not still

def build_missing_reason(info: Dict[str,Any])->str:
    out=[]
    if info["missing_guid"]: out.append("guid")
    if info["missing_thumb"]: out.append("thumb")
    if info["missing_summary"]: out.append("summary")
    if info["missing_rating"]: out.append("rating")
    return ", ".join(out) or "unknown"

def handle_failed_item(lib, rk, info, row, updated_iso):
    title = clean_bidi(info.get("title", "?"))
    reason = ", ".join(k for k, v in info.items() if v and k.startswith("missing"))
    fails = int((row["fail_count"] if row else 0) or 0) + 1

    asyncio.create_task(
        log_extra(
            "failed.log",
            f"FAILED | lib={lib} | key={rk} | title={title} | fails={fails} | missing={reason}"
        )
    )

    if fails >= MAX_FAILS:
        log_sync(f"[DEAD] {lib} | {title} ({rk}) {fails}x failed", "REFRESH")
        asyncio.create_task(
            log_extra(
                "dead.log",
                f"DEAD | lib={lib} | key={rk} | title={title} | fails={fails}"
            )
        )
        db_upsert_media(
            rk, lib, updated_iso, fails, "dead",
            iso_in_days(3650), "Permanent fehlerhaft"
        )
        return fails, True

    cd = COOLDOWN_STEPS_DAYS[min(fails - 1, len(COOLDOWN_STEPS_DAYS) - 1)]
    log_sync(f"[COOLDOWN] {lib} | {title} ({rk}) fail#{fails} ‚Üí {cd}d", "REFRESH")

    db_upsert_media(
        rk, lib, updated_iso, fails, "cooldown",
        iso_in_days(cd), f"Fail {fails} ‚Äì Cooldown {cd}d"
    )

    return fails, False

# =====================================================================
# SMART REFRESH LOOP ‚Äì kompakter, stabiler, fehlerresistenter
# =====================================================================

async def smart_refresh_loop():
    global cpu_vals, cpu_peak

    db_init()
    log_sync(f"SQLite bereit: {DB_PATH}", "DB")
    asyncio.create_task(cpu_sampler())

    # -------------------------------------------------------------
    # PLEX CONNECT
    # -------------------------------------------------------------
    try:
        plex = await plex_connect_async()
        status["plex_name"] = plex.friendlyName
        status["status_line"] = f"‚úÖ Verbunden mit Plex: {plex.friendlyName}"
        tmdb_check_connection()
        status["mode"] = "IDLE"

        tgt = next_target_datetime()
        status["next_run"] = next_run_human(tgt)

        # Health laden
        if os.path.exists(HEALTH_FILE):
            try:
                raw = open(HEALTH_FILE).read().strip()
                st, ts = raw.split("|")
                ld = dt.datetime.strptime(ts, "%d.%m.%Y %H:%M:%S")
                diff = (dt.datetime.now() - ld).days
                status["health"] = (
                    f"üö® Letzter Erfolg vor {diff} Tagen!"
                    if st == "FAIL" or diff > HEALTHCHECK_MAX_DAYS
                    else f"OK (zuletzt: {ts})"
                )
            except:
                status["health"] = "Health-Datei defekt."
        else:
            status["health"] = "Keine Health-Datei."

        await update_embed()

    except Exception as e:
        msg = f"‚ùå Fehler bei Plex-Verbindung: {e}"
        log_sync(msg, "REFRESH")
        status.update({"mode":"ERROR","status_line":msg,"last_error":msg})
        write_health(False)
        await update_embed()
        return

    # =================================================================
    # MAIN LOOP
    # =================================================================
    while True:
        tgt = next_target_datetime()
        status.update({
            "mode": "IDLE",
            "status_line": f"Bereit ‚Äì Plex {status['plex_name']}",
            "next_run": next_run_human(tgt)
        })
        log_sync(f"N√§chster Lauf: {human_until(tgt)}","SCHED")
        await update_embed()

        await asyncio.sleep(max(0,(tgt-dt.datetime.now()).total_seconds()))

        # -------------------------------------------------------------
        # SCAN START
        # -------------------------------------------------------------
        start_ts = dt.datetime.now()
        log_sync("="*80,"REFRESH")
        log_sync(f"SCAN START {start_ts:%d.%m.%Y %H:%M:%S}","REFRESH")

        status.update({
            "mode":"REFRESH",
            "status_line":f"üîÑ L√§uft ({status['plex_name']})",
            "next_run":"‚Äî Lauf aktiv ‚Äî",
            "last_error":""
        })
        await update_embed()

        # Laufbasierte Logs leeren
        for n in ("failed.log","dead.log","recovered.log"):
            try: open(os.path.join(LOG_DIR,n),"w").close()
            except: pass

        stats_checked = stats_fixed = stats_failed = stats_skip = stats_new_dead = 0
        refreshed_libs = []
        time_limit = dt.timedelta(seconds=SCAN_TIME_LIMIT_SECONDS)

        try:
            sections=[s for s in plex.library.sections() if s.type in("movie","show")]
        except Exception as e:
            msg=f"Bibliotheken-Fehler: {e}"
            log_sync(msg,"REFRESH")
            status.update({"mode":"ERROR","status_line":msg,"last_error":msg})
            write_health(False)
            await update_embed()
            continue

        total_secs=len(sections) or 1

        # -------------------------------------------------------------
        # LIB-BY-LIB
        # -------------------------------------------------------------
        for idx,sec in enumerate(sections, start=1):

            if dt.datetime.now()-start_ts >= time_limit:
                log_sync("Zeitlimit erreicht ‚Äì Abbruch.","REFRESH")
                break

            lib = sec.title

            # LOGGEN WELCHE LIB JETZT DRAN IST
            log_sync(f"Starte Library: {lib} ({idx}/{total_secs})", "REFRESH")

            # --- EXCLUDE LIBRARIES ‚Äì komplette Sektion √ºberspringen ---
            if lib in EXCLUDE_LIBRARIES:
                log_sync(f"[EXCLUDE] Bibliothek √ºbersprungen: {lib}", "REFRESH")
                continue

            # ---- Library laden + Runtime messen ----
            start_load = time.time()

            try:
                loop = asyncio.get_running_loop()
                all_items = await loop.run_in_executor(
                    None, lambda: sec.all(sort="updatedAt:desc")
                )
            except:
                log_sync(f"{lib} ‚Äì Plex offline ‚Üí Pause","REFRESH")
                status["mode"] = "PAUSE"
                status["status_line"] = "‚è∏Ô∏è Plex offline."
                await update_embed()
                await asyncio.sleep(10)
                continue

            load_time = time.time() - start_load
            item_count = len(all_items) if all_items else 0

            # NEW: Runtime-Log
            log_sync(
                f"{lib} geladen ({item_count} Items, {load_time:.1f}s)",
                "REFRESH"
            )

            now_dt=dt.datetime.now()
            lookback = now_dt - dt.timedelta(days=SMART_LOOKBACK_DAYS)

            ready_list=[]; new_list=[]; changed_list=[]

            # ---------------------------------------------------------
            # LIB ITEM SORTING
            # ---------------------------------------------------------
            for itm in all_items:

                # EXCLUDED LIB? (superschneller Full-Skip)
                if sec.title in EXCLUDE_LIBRARIES:
                    # Wird nicht geloggt (optional), weil Sorting-Phase extrem h√§ufig ist
                    continue

                if len(ready_list) + len(new_list) + len(changed_list) >= MAX_ITEMS_PER_RUN:
                    break

                rk = str(getattr(itm, "ratingKey", "") or "")
                upd = getattr(itm, "updatedAt", None)
                upd_iso = upd.isoformat() if upd else ""
                row = db_get_media(rk)

                # Cooldown / Dead skip
                if row and row["ignore_until"]:
                    try:
                        ign = dt.datetime.fromisoformat(row["ignore_until"])
                        if ign > now_dt and row["state"] in ("cooldown", "dead"):
                            stats_skip += 1
                            continue
                    except:
                        pass


                is_new = row is None
                is_changed = (
                    upd_iso and row
                    and upd_iso != (row["last_updated_at"] or "")
                    and upd and upd>=lookback
                )
                ready_problem = (
                    row and row["state"] in ("cooldown","dead")
                    and (not row["ignore_until"] or
                         dt.datetime.fromisoformat(row["ignore_until"]) <= now_dt)
                )

                if ready_problem:
                    ready_list.append(itm)
                elif is_new:
                    new_list.append(itm)
                elif is_changed:
                    changed_list.append(itm)

            selected=(ready_list+new_list+changed_list)[:MAX_ITEMS_PER_RUN]
            if not selected:
                log_sync(f"{lib}: keine Items.","REFRESH")
                continue

            # ---------------------------------------------------------
            # PROCESS ITEMS
            # ---------------------------------------------------------
            fixed_lib = 0

            for itm in selected:

                # EXCLUDED LIB? ‚Üí sauber skippen + loggen
                if lib in EXCLUDE_LIBRARIES:
                    log_sync(f"[EXCLUDE] {lib} | {itm.title}", "REFRESH")
                    continue

                # Zeitlimit √ºberschritten?
                if dt.datetime.now() - start_ts >= time_limit:
                    break

                # Plex Scan? ‚Üí warten
                if await plex_is_scanning_async(plex):
                    await wait_until_plex_ready(plex)

                stats_checked += 1
                rk = str(getattr(itm, "ratingKey", ""))
                upd = getattr(itm, "updatedAt", None)
                upd_iso = upd.isoformat() if upd else ""
                row = db_get_media(rk)

                # RECOVERED?
                if row and row["state"] == "dead" and upd_iso != (row["last_updated_at"] or ""):
                    asyncio.create_task(
                        log_extra("recovered.log",
                                f"RECOVERED | {lib} | {rk} | {itm.title}")
                    )
                    db_upsert_media(rk, lib, upd_iso, 0, "active", None, "recovered")
                    row = db_get_media(rk)

                # Pr√ºfen, ob Refresh n√∂tig
                need, info = needs_refresh(itm)
                if not need:
                    db_upsert_media(rk, lib, upd_iso, 0, "active", None, None)
                    continue

                ok=False
                try:
                    ok=await refresh_item_and_check(plex,itm)
                except:
                    status["mode"]="PAUSE"
                    status["status_line"]="‚è∏Ô∏è Plex offline."
                    await update_embed()
                    await asyncio.sleep(10)
                    continue

                if ok:
                    fixed_lib+=1; stats_fixed+=1
                    db_upsert_media(rk,lib,upd_iso,0,"active",None,"fixed")
                    continue

                tmdb_id=tmdb_find_guid_for_item(itm)
                if tmdb_id:
                    try:
                        if set_guid(itm,tmdb_id):
                            fixed_lib+=1; stats_fixed+=1
                            db_upsert_media(
                                rk,lib,upd_iso,0,"active",None,f"guid:{tmdb_id}"
                            )
                            continue
                    except:
                        status["mode"]="PAUSE"
                        status["status_line"]="‚è∏Ô∏è Plex offline."
                        await update_embed()
                        await asyncio.sleep(10)
                        continue

                stats_failed+=1
                row=db_get_media(rk)
                _, dead = handle_failed_item(lib,rk,info,row,upd_iso)
                if dead: stats_new_dead+=1

            if fixed_lib>0:
                refreshed_libs.append(f"‚Ä¢ {lib}: {fixed_lib} gefixt")

        # -------------------------------------------------------------
        # SCAN ENDE
        # -------------------------------------------------------------
        end_ts=dt.datetime.now()
        duration=(end_ts-start_ts).total_seconds()

        avg_cpu = sum(cpu_vals)/len(cpu_vals) if cpu_vals else 0
        peak_cpu = cpu_peak

        cpu_vals.clear(); cpu_peak=0.0

        main_line=(
            f"{stats_fixed} gefixt ¬∑ "
            f"{stats_failed} fehlgeschlagen ¬∑ "
            f"{stats_checked} gepr√ºft ¬∑ Dauer: {format_dur(duration)}"
        )

        status["last_refresh"]=f"{start_ts:%d.%m.%Y %H:%M:%S} ‚Äì {main_line}"
        status["last_refresh_details"]="\n".join(refreshed_libs)
        status["cpu_line"]=f"‚åÄ {avg_cpu:.1f}% / Peak {peak_cpu:.1f}%"
        status["status_line"]=f"Refresh abgeschlossen ({status['plex_name']})"

        total_dead=db_count_dead_total()
        ts_now=dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
        status["stats_block"]=(
            f"üìä Stats ‚Äì {ts_now}\n"
            f"‚Ä¢ Gepr√ºft: {stats_checked}\n"
            f"‚Ä¢ Gefixt: {stats_fixed}\n"
            f"‚Ä¢ Fehlgeschlagen: {stats_failed}\n"
            f"‚Ä¢ √úbersprungen: {stats_skip}\n"
            f"‚Ä¢ Neu tot: {stats_new_dead}\n"
            f"‚Ä¢ Gesamt tot: {total_dead}"
        )

        write_health(True)
        await update_embed()

        log_sync(f"SCAN ENDE {end_ts:%d.%m.%Y %H:%M:%S} | {main_line}","REFRESH")
        log_sync("="*80,"REFRESH")

# =====================================================================
# PERIODIC HEALTH CHECK
# =====================================================================

async def periodic_health(cb):
    while True:
        try:
            if not os.path.exists(HEALTH_FILE):
                status["health"] = "Keine Health-Datei."
            else:
                raw = open(HEALTH_FILE).read().strip()
                st, ts = raw.split("|")
                ld = dt.datetime.strptime(ts, "%d.%m.%Y %H:%M:%S")
                diff = (dt.datetime.now() - ld).days
                status["health"] = (
                    f"üö® Letzter Erfolg vor {diff} Tagen!"
                    if st == "FAIL" or diff > HEALTHCHECK_MAX_DAYS
                    else f"OK (zuletzt: {ts})"
                )
        except Exception as e:
            status["health"] = f"Health-Fehler: {e}"

        await cb()
        await asyncio.sleep(HEALTHCHECK_INTERVAL_MINUTES * 60)

# =====================================================================
# RUNNER ‚Äì ohne Discord (Standalone oder Telegram-Only)
# =====================================================================

async def _runner_no_discord():
    log_sync("Starte ohne Discord-Bot‚Ä¶", "MAIN")
    asyncio.create_task(periodic_health(update_embed))
    await smart_refresh_loop()

# =====================================================================
# MAIN ‚Äì Discord / Telegram / Standalone Boot
# =====================================================================

def main():
    global tg_bot, bot

    # Health-File initialisieren
    if not os.path.exists(HEALTH_FILE):
        open(HEALTH_FILE, "w").write("OK|" + dt.datetime.now().strftime("%d.%m.%Y %H:%M:%S"))
        status["health"] = "OK (initial)"

    # -------------------------------------------------------------
    # TELEGRAM BOT (sync initialisieren ‚Äì ohne async Logging!)
    # -------------------------------------------------------------
    if ENABLE_TELEGRAM and ENABLE_TELEGRAM_IMPORT:
        try:
            tg_bot = TgBot(
                token=TELEGRAM_BOT_TOKEN,
                session=AiohttpSession()
            )
            # WICHTIG: Kein log_sync hier! Das erzeugt Tasks vor Bot-Start.
            print("[TELEGRAM] Telegram Bot gestartet", flush=True)
        except Exception as e:
            print(f"[TELEGRAM] Fehler: {e}", flush=True)
            tg_bot = None


    # -------------------------------------------------------------
    # DISCORD BOT
    # -------------------------------------------------------------
    if ENABLE_DISCORD and ENABLE_DISCORD_IMPORT:

        # --- Discord logging reduzieren ---
        import logging
        logging.getLogger("discord").setLevel(logging.ERROR)
        logging.getLogger("discord.client").setLevel(logging.ERROR)
        logging.getLogger("discord.http").setLevel(logging.ERROR)

        # Unterdr√ºckt Gateway-Reconnect Messages
        logging.getLogger("discord.gateway").disabled = True
        logging.getLogger("discord.state").disabled = True

        intents = discord.Intents.none()
        intents.guilds = True

        bot = commands.Bot(command_prefix="!", intents=intents)

        @bot.event
        async def on_ready():
            log_sync("Discord online.", "DISCORD")
            # Jetzt ist der Event-Loop sicher aktiv ‚Üí async OK
            asyncio.create_task(smart_refresh_loop())
            asyncio.create_task(periodic_health(update_embed))

        bot.run(DISCORD_TOKEN)
        return  # Discord-Modus beendet das Programm hier korrekt


    # -------------------------------------------------------------
    # STANDALONE (kein Discord-Bot)
    # -------------------------------------------------------------
    loop = asyncio.get_event_loop()
    loop.run_until_complete(_runner_no_discord())


# =====================================================================
# RUN
# =====================================================================

if __name__ == "__main__":
    print("üöÄ Starte Plex Smart-Refresher 4.3 Compact Edition ‚Ä¶", flush=True)
    main()
